# Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments.

max_length = max([len(arg) for arg in args])
    for arg in args:
        if len(arg) < max_length:
            difference = max_length - len(arg)
            arg.extend([None] * difference)
    nested = [list((args)) for args in zip(*args)]
    return [x for sub in nested for x in sub]


# For each string passed to the decode function return its translation.

def tongues(text):
    vowels = 'aiyeou'
    consonants = 'bkxznhdcwgpvjqtsrlmf'
    decoded_text = ''

    for char in text:
        if char in consonants:
            indx = consonants.index(char)
            decoded_text += consonants[(indx + 10) % 20]
        elif char in consonants.upper():
            indx = consonants.index(char.lower())
            decoded_text += consonants[(indx + 10) % 20].upper()
        elif char in vowels:
            indx = vowels.index(char)
            decoded_text += vowels[(indx + 3) % 6]
        elif char in vowels.upper():
            indx = vowels.index(char.lower())
            decoded_text += vowels[(indx + 3) % 6].upper()
        else:
            decoded_text += char
    return decoded_text



# Implement a function which behaves like the 'uniq -c' command in UNIX.

def uniq_c(seq):
    if not seq:
        return []
    if len(seq) == 1:
        return [(seq[0], 1)]
    count = 1
    res = []
    for i in range(1, len(seq)):
        if seq[i-1] != seq[i]:
            res.append((seq[i-1], count))
            count = 1
        else:
            count += 1
    if seq[i-1] != seq[i]:
        res.append((seq[i], count))
    else:
        res.append((seq[i], count))
    return res



# For each number in strng calculate its "weight" and then find two numbers of strng that have the smallest difference of weights ie that are the closest, with the smallest weights and with the smallest indices in strng

def closest(strng):
    numbers = strng.split()
    weight_lst = []
    for i, n in enumerate(numbers):
        weight = sum([int(x) for x in n])
        weight_lst.append((weight, i, int(n)))
    sorted_weight_lst = sorted(weight_lst, key=lambda x: x[0])
    min_diff = float('inf')
    current_diff = 0
    tracker = []
    for i in range(1, len(sorted_weight_lst)):
        current_diff = abs(sorted_weight_lst[i-1][0] - sorted_weight_lst[i][0])
        if current_diff < min_diff:
            min_diff = current_diff
            tracker = [list(sorted_weight_lst[i-1]), list(sorted_weight_lst[i])]
    return tracker



















