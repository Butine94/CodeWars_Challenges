# Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments.

max_length = max([len(arg) for arg in args])
    for arg in args:
        if len(arg) < max_length:
            difference = max_length - len(arg)
            arg.extend([None] * difference)
    nested = [list((args)) for args in zip(*args)]
    return [x for sub in nested for x in sub]


# For each string passed to the decode function return its translation.

def tongues(text):
    vowels = 'aiyeou'
    consonants = 'bkxznhdcwgpvjqtsrlmf'
    decoded_text = ''

    for char in text:
        if char in consonants:
            indx = consonants.index(char)
            decoded_text += consonants[(indx + 10) % 20]
        elif char in consonants.upper():
            indx = consonants.index(char.lower())
            decoded_text += consonants[(indx + 10) % 20].upper()
        elif char in vowels:
            indx = vowels.index(char)
            decoded_text += vowels[(indx + 3) % 6]
        elif char in vowels.upper():
            indx = vowels.index(char.lower())
            decoded_text += vowels[(indx + 3) % 6].upper()
        else:
            decoded_text += char
    return decoded_text



# Implement a function which behaves like the 'uniq -c' command in UNIX.

def uniq_c(seq):
    if not seq:
        return []
    if len(seq) == 1:
        return [(seq[0], 1)]
    count = 1
    res = []
    for i in range(1, len(seq)):
        if seq[i-1] != seq[i]:
            res.append((seq[i-1], count))
            count = 1
        else:
            count += 1
    if seq[i-1] != seq[i]:
        res.append((seq[i], count))
    else:
        res.append((seq[i], count))
    return res





