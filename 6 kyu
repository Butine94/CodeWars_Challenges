# Given an array of integers, find the one that appears an odd number of times.

def find_it(seq):
    counts = {n: seq.count(n) for n in seq if seq.count(n) % 2}
    return list(counts.keys())[0]

# Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. 

def duplicate_count(text):
    text = text.lower()
    result = [x for x in text if text.count(x) >= 2]
    return len(set(result)) if not [] else 0


# Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.

def unique_in_order(sequence):
    return ([sequence[i] for i in range(len(sequence) - 1) if sequence[i] != sequence[i+1]] + [sequence[-1]]) if sequence else []


# convert a string to a new string where each character in the new string is "(" if that character appears only once in the original string, or ")" if that character appears more than once in the original string

def duplicate_encode(word):
    word_lower = word.lower()
    return ''.join(['(' if word_lower.count(x) == 1 else ')' for x in word_lower])


# Given a lowercase string that has alphabetic characters only and no spaces, return the highest value of consonant substrings. 

import re

def solve(s):
    alpha = '_abcdefghijklmnopqrstuvwxyz'
    str = re.split(r'[aeiou]', s)
    return max([sum([alpha.index(letter) for letter in word]) for word in str])



# Write a function that when given a number >= 0, returns an Array of ascending length subarrays.

def pyramid(n):
    lst = list(range(1, n + 1))
    return [[1, ]  * digit for digit in lst]


# Complete the solution so that it splits the string into pairs of two characters.

def solution(s):
    odd = [s[i] for i in range(0, len(s), 2)]
    even = [s[i] for i in range(1, len(s), 2)]
    if len(odd) == len(even):
        return [x + y for x, y in zip(odd, even)]
    else:
        return [x + y for x, y in zip(odd, even)] + [odd[-1] + '_']

# Find the first character that repeats in a String and return that character.

from collections import Counter

def first_dup(s):
    if len(set(s)) == len(s):
        return None
    counts = Counter(s)
    for v in counts.values():
            return [k for k, v in counts.items() if v >= 2][0]


# Create a function isAlt() that accepts a string as an argument and validates whether the vowels (a, e, i, o, u) and consonants are in alternate order.

def is_alt(s):
    vowels = 'aeiou'
    for i in range(1, len(s)):
        if (s[i-1] in vowels) == (s[i] in vowels):
            return False
        if (s[i-1] not in vowels) == (s[i] not in vowels):
            return False
    return True


# write a function which will reverse the vowels in a string.

def reverse_vowels(s):
    vowels = 'aeiouAEIOU'
    vowels_lst = [letter for letter in s if letter in vowels]
    result = []
    for letter in s:
        if letter not in vowels:
            result.append(letter)
        else:
            result.append(vowels_lst.pop())
    return ''.join(result)


# Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.

def sort_array(a):
    odd = sorted([x for x in a if x % 2 == 1])
    even = sorted([x for x in a if x % 2 == 0], reverse=True)
    result = []
    for n in a:
        if n % 2 == 1:
            result.append(odd.pop(0))
        else:
            result.append(even.pop(0))
    return result


# Your task is to return an array giving each number its rank in the array.

def rankings(arr):
    sorted_arr = sorted(arr, reverse=True)
    dict = {n: i for i, n in enumerate(sorted_arr, 1)}
    result = []
    for x in arr:
        for k, v in dict.items():
            if k == x:
                result.append(dict[k])
    return result


# Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.

def find_missing_letter(chars):
    alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in range(1, len(chars)):
        if ord(chars[i-1]) + 1 != ord(chars[i]):
            indx = alpha.index(chars[i-1])
            return alpha[indx+1]


# write a function that does just what the title suggests

def first_n_smallest(arr, n):
    sorted_arr = sorted(arr)[:n]
    result = []
    for n in arr:
        if n in sorted_arr:
            result.append(n)
            sorted_arr.remove(n)
    return result


# How many characters do we have to remove from the first string to get the second string?

def solve(a, b):
    if len(b) > len(a):
        return 0
    new_str = a
    for letter in b:
        if letter in new_str:
            new_str = new_str.replace(letter, '', 1)
        else:
            return 0
    return len(new_str)

# Given an array of integers of any length, return an array that has 1 added to the value represented by the array.

def up_array(arr):
    if any(x < 0 or x > 9 for x in arr):
        return None
    number = int(''.join(map(str, arr)))+1
    return list(map(int, str(number))) if arr[0] != 0


# Finish the solution so that it takes an input n (integer) and returns a string that is the decimal representation of the number grouped by commas after every 3 digits.

def group_by_commas(n):
    n = str(n)
    if len(n) <= 3:
        return n
    reversed_n = n[::-1]
    st = ''
    for i, n in enumerate(reversed_n, 1):
        if i % 3 == 0:
            st += f'{n},'
        else:
            st += n
    return st[::-1].lstrip(',')


# Complete the solution so that it returns true if it contains any duplicate argument values. 

from collections import Counter

def solution(*args):
    if not args:
        return False
    
    counts = Counter(args) 
    return any(count > 1 for count in counts.values())


# The hamming distance between a pair of numbers is the number of binary bits that differ in their binary notation.

def hamming_distance(a, b):
    bin_a = bin(a)[2:]
    bin_b = bin(b)[2:]
    difference = abs(len(bin_a) - len(bin_b))
    if len(bin_b) > len(bin_a):
        bin_a = '0' * difference + bin_a
    if len(bin_a) > len(bin_b):
        bin_b = '0' * difference + bin_b
    count = 0
    for i in range(len(bin_a)):
        if bin_a[i] != bin_b[i]:
            count += 1
    return count


# Your task is to split the string into separate digits

def uncollapse(digits):
    words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
    number = ''
    result = []
    for letter in digits:
        number += letter
        for word in words:
            if word == number:
                result.append(word)
                number = ''
    return ' '.join(result)


# you will be given an array of strings and your task is to remove all consecutive duplicate letters from each string in the array.

def dup(arr):
    result = []
    for word in arr:
        duplicates = [word[0]]
        for i in range(1, len(word)):
            if word[i-1] != word[i]:
                duplicates.append(word[i])
        duplicates = ''.join(duplicates)
        result.append(duplicates)
    return result


# Find the sum of the digits of all the numbers from 1 to N (both ends included).

def compute_sum(n):
    lst = list(range(1, n+1))
    sums = 0
    for n in lst:
        if n <= 9:
            sums += n
        else:
            n = str(n)
            for digit in n:
                sums += int(digit)
    return sums


# Implement a function, so it will produce a sentence out of the given parts.

import re

def make_sentences(parts):
    result = [parts[0]]
    for x in parts[1:]:
        if re.findall(r'[\dA-Za-z]', x):
            st = f' {x}'
            result.append(st)
        elif re.findall(r'[,]', x):
            st = f'{x}'
            result.append(st)
    result.append('.')
    return ''.join(result)


# You have to sort the inner content of every word of a string in descending order.

def sort_the_inner_content(words):
    words = words.split()
    result = []
    for word in words:
        if len(word) > 2:
            inner_word = sorted(word[1:-1], reverse=True)
            complete_word = word[0] + ''.join(inner_word) + word[-1]
            result.append(complete_word)
        else:
            result.append(word)
    return ' '.join(result)


# Given an integer n, find the maximal number you can obtain by deleting exactly one digit of the given number.

def delete_digit(n):
    n = str(n)
    max_number = 0
    current_number = 0
    for i in range(len(n)):
        current_number = int(n[:i] + n[i+1:])
        if current_number > max_number:
            max_number = current_number
    return max_number


# The summary is made by adding up the number of digits of all page numbers.

def amount_of_pages(summary):
    n = 0
    for i in range(1,summary+1):
        n += len(str(i))
        if n >= summary:
            return i
    return None


# Create a moreZeros function which will receive a string for input, and return an array

def more_zeros(s):
    binary = [bin(ord(x))[2:] for x in s]
    result = []
    for i, num in enumerate(binary):
        if num.count('0') > num.count('1') and s[i] not in result:
            result.append(s[i])
    return result


# Find the longest substring in alphabetical order.

def longest(st):
    current_st = st[0]
    longest_st = ''
    for i in range(1, len(st)):
        if ord(st[i-1]) <= ord(st[i]):
            current_st += st[i]
        else:
            if len(current_st) > len(longest_st):
                longest_st = current_st
            current_st = st[i]
    
    if len(current_st) > len(longest_st):
        longest_st = current_st
    
    return longest_st


# Write a function that takes a string and returns an array of the repeated characters (letters, numbers, whitespace) in the string.

def remember(str_):
    str_ = str_.lower()
    result = []
    duplicates = []
    for char in str_:
        if char not in result:
            result.append(char)
        elif char in result and char not in duplicates:
            duplicates.append(char)
    return duplicates

# Could you make a program that makes this string uppercase and gives it sorted in alphabetical order by last name.

def meeting(s):
    s = s.upper().split(';')
    result = []
    for name in s:
        first_name = name[:name.index(':')]
        last_name = name[name.index(':') + 1:]
        x = last_name, first_name
        result.append(x)
    sorted_result = sorted(result, key=lambda x: (x[0], x[1]))
    return ''.join(f'({first}, {second})' for first, second in sorted_result)


# Your job is to sum only the numbers that are the same and consecutive

def sum_consecutives(nums):
    result = []
    total = nums[0]
    for i in range(1, len(nums)):
        if nums[i-1] == nums[i]:
            total += nums[i]
        else:
            result.append(total)
            total = nums[i]
    result.append(total)
    return result


# The return of the function shall first be sorted by yymm, then by the name (which varies in length).

def sort_me(courses): 
    word_split = [word.split('-') for word in courses]
    sorted_words = sorted(word_split, key=lambda x: (x[1], x[0]))
    return [f'{word}-{number}' for word, number in sorted_words]


# Given a string of digits, return the longest substring with alternating odd/even or even/odd digits.

def longest_substring(digits):
    if not digits:
        return ""
    current_str = digits[0]
    longest_str = ''
    for i in range(1, len(digits)):
        if int(digits[i-1]) % 2 != int(digits[i]) % 2:
            current_str += digits[i]
        else:
            if len(current_str) > len(longest_str):
                longest_str = current_str
            current_str = digits[i]
    if len(current_str) > len(longest_str):
        longest_str = current_str
    return longest_str


# Complete the function that takes an array of strings of common bird names from North America, and create the codes for those names based on the rules above.

def bird_code(bird_names):
    codes = []
    for name in bird_names:
        name = name.replace('-', ' ')
        words = name.split()
        code = ''
        if len(words) == 1:
            code = words[0][:4].upper()
        elif len(words) == 2:
            code = (words[0][:2] + words[1][:2]).upper()
        elif len(words) == 3:
            code = (words[0][0] + words[1][0] + words[2][:2]).upper()
        elif len(words) >= 4:
            code = ''.join(word[0] for word in words).upper()
        codes.append(code)
    return codes


# Let's help with our own Hashtag Generator

import re

def generate_hashtag(s):
    if not s or s == '#':
        return False
    words = re.findall('\w+', s)
    res = '#' + ''.join(word.capitalize() for word in words)
    if len(res) > 140:
        return False
    return res


# Complete the function/method so that it takes a PascalCase string and returns the string in snake_case notation

import re

def to_underscore(string):
    if type(string) == int:
        return str(string)
    words = re.findall('[A-Z][a-z0-9]*', string)
    return ('_'.join(words)).lower()


# Write a function that accepts a string, and returns true if it is in the form of a phone number.

import re

def valid_phone_number(phone_number):
    return bool(re.fullmatch(r'^\(\d{3}\)\s\d{3}\-\d{4}$', phone_number))


# You will create 2 string methods

import re

def is_audio(file_name):
    return bool(re.fullmatch(r'^[A-Za-z0-9]+(.mp3|.flac|.alac|.aac)$', file_name))

def is_img(file_name):
    return bool(re.fullmatch(r'^[A-Za-z]+(.jpg|.jpeg|.png|.bmp|.gif)$', file_name))


# if the number of meetup participants representing any of the three programming languages is at most 2 times higher than the number of developers representing any of the remaining programming languages

def is_language_diverse(lst):
    languages = [dev['language'] for dev in lst]
    languages_count = {language: languages.count(language) for language in languages}
    sorted_languages = sorted(languages_count.values())
    if sorted_languages[0] * 2 < sorted_languages[-1]:
        return False
    return True


# Given an array (arr) as an argument complete the function countSmileys that should return the total number of smiling faces.

import re

def count_smileys(arr):
    count = 0
    for face in arr:
        if re.match('[:;][-~]?[)D]', face):
            count += 1
    return count


# Given an integer, return a string with dash '-' marks before and after each odd digit, but do not begin or end the string with a dash mark.

import re

def dashatize(num):
    num = str(num)
    return '-'.join(re.findall('[13579]|[02468]+', num))


# write a method, that return the length of the missing array.

def get_length_of_missing_array(arrays):
    if not arrays or any(not arr for arr in arrays):
        return 0
    arrays = sorted(arrays, key=lambda arr: len(arr))
    length = [len(arr) for arr in arrays]
    for i in range(1, len(length)):
        if length[i-1] + 1 != length[i]:
            return length[i-1] + 1


# write a function called isOddHeavy or is_odd_heavy that accepts an integer array and returns true if the array is odd-heavy else return false.

def is_odd_heavy(arr):
    arr = sorted(arr, reverse=True)
    even = []
    odd = []
    for i, num in enumerate(arr):
        if num % 2 == 0:
            even.append(num)
        if num % 2 == 1:
            odd.append(num)
    length = len(odd)
    if length == 0:
        return False
    if arr[length:] != even:
        return False
    return True


# The function must return the sequence of titles that match the string passed as an argument.

import re

def search(titles, term):
    res = []
    for title in titles:
        match = re.search(term, title, re.IGNORECASE)
        if match:
            res.append(title)
    return res











def max_and_min(arr1,arr2):
    max_diff = float('-inf')
    min_diff = float('inf')
    for n in arr1:
        for x in arr2:
            diff = abs(n - x)
            if diff > max_diff:
                max_diff = diff
            if diff < min_diff:
                min_diff = diff
    return [max_diff, min_diff]


def typist(s):
    count = 0
    for i in range(1, len(s)):
        if s[i].islower() and s[i-1].islower():
            count += 1
        if s[i].islower() and s[i-1].isupper():
            count += 2
        if s[i].isupper() and s[i-1].isupper():
            count += 1
        if s[i].isupper() and s[i-1].islower():
            count += 2
    start = [1 if x.islower() else 2 for x in s[0]][0]
    return count + start


import math

def lowest_product(num):
    if len(num) < 4:
        return "Number is too small"
    minimum = float('inf')
    for i in range(len(num) - 3):
        sums = math.prod(int(digit) for digit in num[i:i+4])
        if sums < minimum:
            minimum = sums
    return minimum


def solution(s):
    alpha = 'abcdefghijklmnopqrstuvwxy'
    result = []
    st = s[0]
    for i in range(1, len(s)):
        if ord(s[i-1]) + 1 == ord(s[i]):
            st += s[i]
        else:
            result.append(st)
            st = s[i]
    result.append(st)
    reverse = [x[::-1] if len(x) > 1 else x for x in result]
    return ''.join(reverse)


def sort_array(array):
    odd = sorted([x for x in array if x % 2])
    result = []
    for n in array:
        if n % 2:
            result.append(odd.pop(0))
        else:
            result.append(n)
    return result


def clean_string(s):
    result = []
    for char in s:
        if char == '#' and result:
            result.pop()
        else:
            result.append(char)
    return ''.join(result)


def clean_string(s):
    result = []
    for char in s:
        if char == '#' and result:
            result.pop()
        else:
            result.append(char)
    return ''.join([x for x in result if x != '#'])


from collections import Counter

def highest_rank(arr):
    counts = Counter(arr)
    max_value = max([x for x in counts.values()])
    return max([k for k, v in counts.items() if v == max_value])


def longest_repetition(chars):
    if not chars:
        return ('', 0)
    count = 1
    result = []
    for i in range(1, len(chars)):
        if chars[i-1] == chars[i]:
            count += 1
        else:
            x = (chars[i-1], count)
            result.append(x)
            count = 1
    x = (chars[-1], count)
    result.append(x)
    return sorted(result, key=lambda x: x[1], reverse=True)[0]


def solve(arr):
    return sorted(arr, key=lambda x: (-arr.count(x), x))


def average_string(s):
    if not s:
        return 'n/a'
    numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
    sums = 0
    for n in s.split():
        if n not in numbers:
            return 'n/a'
        else:
            x = numbers.index(n)
            sums += x
    average = sums // len(s.split())
    for i, number in enumerate(numbers):
        if average == i:
            return number


from collections import Counter

def number_of_pairs(gloves):
    counts = Counter(gloves).items()
    pairs = {k: v // 2 for k, v in counts}
    return sum(pairs.values())


import re

def remove_url_anchor(url):
    return re.sub(r'#[^>]+', '', url)






